<!DOCTYPE html>
<html>
<head>
<title>why-curry-helps.md</title>
<!-- 2015-03-06 Fri 09:43 -->
<meta  charset="utf-8">
<meta  name="generator" content="Org-mode">
<meta  name="author" content="Jichao Ouyang">
<meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/style/pixyll.css" />
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="/index.html"> UP </a>
 |
 <a accesskey="H" href="https://oyanglul.us/~jichao.ouyang.html"> HOME </a>
</div><div id="content">
<h1 class="title">why-curry-helps.md</h1>
<nav id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">柯里化 currying</a>
<ul>
<li><a href="#sec-1-1">为什么要柯里化</a>
<ul>
<li><a href="#sec-1-1-1">我们来解一个问题</a></li>
<li><a href="#sec-1-1-2">柯里化函数接口</a></li>
<li><a href="#sec-1-1-3">自动柯里化</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</nav>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">柯里化 currying</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">为什么要柯里化</h3>
<div class="outline-text-3" id="text-1-1">
<p>
还记得 Haskell Curry吗<img src="http://s3.amazonaws.com/lyah/curry.png" alt="curry.png">
</p>

<p>
多巧啊, 人家姓 Curry 名 Haskell, 难怪 Haskell 语言会自动柯里化, 呵呵.
但是不奇怪吗, 为什么要柯里化呢. 为什么如此重要导致 Haskell
会默认自动柯里化所有函数, 不就是返回一个部分配置好的函数吗.
</p>

<p>
我们来看一个 Haskell 的代码.
</p>

<div class="org-src-container">

<pre class="src src-haskell">max 3 4
(max 3) 4
</pre>
</div>

<p>
结果都是4, 这有设么用呢.
</p>

<p>
这里看不出来, 放到=高阶函数=试试. 什么? 看不懂天书 Haskell, 来看看
JavaScript 吧.
</p>
</div>

<div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">我们来解一个问题</h4>
<div class="outline-text-4" id="text-1-1-1">
</div><ul class="org-ul"><li><a id="sec-1-1-1-1" name="sec-1-1-1-1"></a>1. 写一个函数, 可以连接字符数组, 如 =f(['1','2']) =&gt; '12'=<br ><div class="outline-text-5" id="text-1-1-1-1">
<p>
好吧,如果不用柯里化, 怎么写? 啊哈 <code>reduce</code>
</p>

<pre class="example">
var concatArray = function(chars){
  return chars.reduce(function(a, b){
    return a.concat(b);
  });
}
concat(['1','2','3']) // =&gt; '123'
</pre>

<p>
很简单,对吧.
</p>
</div>
</li>

<li><a id="sec-1-1-1-2" name="sec-1-1-1-2"></a>2. 现在我要其中所有数字加1, 然后在连接<br ><div class="outline-text-5" id="text-1-1-1-2">
<pre class="example">
var concatArray = function(chars, inc){
  return chars.map(function(char){
    return (+char)+inc + '';
  }).reduce(function(a,b){
      return a.concat(b)
  });
}
console.log(concatArray(['1','2','3'], 1))// =&gt; '234'
</pre>
</div>
</li>

<li><a id="sec-1-1-1-3" name="sec-1-1-1-3"></a>3. 所有数字乘以2, 再重构试试看<br ><div class="outline-text-5" id="text-1-1-1-3">
<pre class="example">
var multiple = function(a, b){
  return +a*b + ''
}
var concatArray = function(chars, inc){
  return chars.map(function(char){
    return multiple(char, inc);
  }).reduce(function(a,b){
      return a.concat(b)
  });
}
console.log(concatArray(['1','2','3'], 2)) // =&gt; '246'
</pre>

<p>
是不是已经看出问题了呢?
如果我在需要每个数字都减2,是不是很麻烦呢.需要将=map= 参数匿名函数中的
multiple 函数换掉. 这样一来=concatArray=就不能同时处理加, 乘和减?
那么怎么能把他提取出来呢? 来对比下柯里化的解法.
</p>
</div>
</li></ul>
</div>

<div id="outline-container-sec-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">柯里化函数接口</h4>
<div class="outline-text-4" id="text-1-1-2">
<pre class="example">
var multiple = function(a){
  return function(b){
    return +b*a + ''
  }
}

var plus = function(a){
  return function(b){
    return (+b)+a + ''
  }
}
var concatArray = function(chars, stylishChar){
  return chars.map(stylishChar)
    .reduce(function(a,b){
      return a.concat(b)
  });
}
console.log(concatArray(['1','2','3'], multiple(2)))
console.log(concatArray(['1','2','3'], plus(2)))
</pre>

<p>
有什么不一样呢 1. 处理数组中字符的函数被提取出来, 作为参数传入 2.
提取成柯里化的函数, 部分配置好后传入, 好处显而易见, 这下接口非常通畅
无论是外层调用
</p>

<pre class="example">
concatArray(['1','2','3'], multiple(2))
</pre>

<p>
还是内部的 map 函数
</p>

<pre class="example">
chars.map(stylishChar)
</pre>

<p>
这些接口都清晰了很多, 不是吗
</p>

<p>
这就是函数式的思想, 用已有的函数组合出新的函数, 而柯里化每消费一个参数,
都会返回一个新的部分配置的函数, 这为函数组合提供了更灵活的手段,
并且使得接口更为流畅.
</p>
</div>
</div>

<div id="outline-container-sec-1-1-3" class="outline-4">
<h4 id="sec-1-1-3">自动柯里化</h4>
<div class="outline-text-4" id="text-1-1-3">
<p>
在 Haskell 语言中, 函数是会自动柯里化的:
</p>

<div class="org-src-container">

<pre class="src src-haskell">max 3 4
</pre>
</div>

<p>
其实就是
</p>

<pre class="example">
(max 3) 4
</pre>

<p>
可以看看=max=与=max 3=函数的 类型
</p>

<div class="org-src-container">

<pre class="src src-haskell">ghci&gt; :t max
max :: Ord a =&gt; a -&gt; a -&gt; a
</pre>
</div>

<p>
看明白了么, <code>Ord a =&gt;</code> 表示类型约束为可以比较大小的类型, 因此=max=
的类型可以翻译成: 当给定一个=a=, 会得到=a -&gt; a=,
再看看=max 3=的类型就好理解了
</p>

<pre class="example">
ghci&gt; :t max 3
(Num a, Ord a) =&gt; a -&gt; a
</pre>

<p>
左侧表示类型约束 <code>a=可以是=Ord</code> 或者=Num=,
意思是=max 3=还是一个函数,如果给定一个=Ord=或者=Num= 类型的参数
则返回一个=Ord=或者=Num=.
</p>

<p>
现在是不是清晰了, 在 Haskell 中每给定一个参数, 函数如果是多参数的,
该函数还会返回一个处理余下参数的函数. 这就是自动柯里化.
</p>

<p>
而在 Javascript(以及大多数语言) 中不是的, 如果给定多参函数的部分参数,
函数会默认其他参数是=undefined=, 而不会返回处理剩余参数的函数.
</p>

<div class="org-src-container">

<pre class="src src-js"><span style="color: #a020f0;">function</span> <span style="color: #0000ff;">willNotCurry</span>(<span style="color: #b8860b;">a</span>, <span style="color: #b8860b;">b</span>, <span style="color: #b8860b;">c</span>) {
    console.log(a, b, c)
    <span style="color: #a020f0;">return</span> a*b-c;
}
willNotCurry(1)
<span style="color: #b22222;">// </span><span style="color: #b22222;">=&gt; NaN</span>
<span style="color: #b22222;">// </span><span style="color: #b22222;">=&gt; 1 undefined undefined</span>
</pre>
</div>

<p>
如果使用自动柯里化的库 <a href="https://github.com/CrossEye/eweda">eweda</a>,
前面的例子简直就完美了
</p>

<pre class="example">
var multiple = curry(function(a, b){
  return +b*a + ''
})
var plus = curry(function(a, b){
  return (+b)+a + ''
})
</pre>

<p>
<a href="http://jsbin.com/hamoq/4/embed?js,console">完整代码</a>
</p>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p>Author: Jichao Ouyang</p>
<p><a href="https://travis-ci.org/jcouyang/blog"><img src="https://travis-ci.org/jcouyang/blog.svg?branch=master"></a> with <a href="http://www.gnu.org/software/emacs/">Emacs</a> 24.3.1 (<a href="http://orgmode.org">Org</a> mode 8.2.10)</p>
<p><a href="http://pipes.yahoo.com/pipes/pipe.run?_id=1096b1ad01dc8d4309ab448eefc442f1&_render=rss&orgblogurl=https://blog.oyanglul.us/">RSS</a> | <a href="/theindex.html">INDEX</a></p>

<!-- Google Analystics -->
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-32314154-10', 'auto');
  ga('send', 'pageview');

</script>
<!-- Disqus -->
<div id="disqus_thread"></div>
<script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    var disqus_shortname = 'orgblog';
    
    /* * * DON'T EDIT BELOW THIS LINE * * */
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
<!-- Swiftype Search -->
<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
  (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
  e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v1/st.js','_st');

  _st('install','eGLqWnAM75a66SiXKVW3');
</script>
</div>
</body>
</html>
